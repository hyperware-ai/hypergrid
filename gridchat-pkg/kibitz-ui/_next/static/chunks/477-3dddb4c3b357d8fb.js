"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[477],{1491:(e,t,r)=>{function n(e){return e.replace(/[^a-zA-Z0-9_]/g,"_").toLowerCase()}function o(e){var t,r,o,i;let s=e.description||"";s.length>1024&&(console.warn("Tool description for '".concat(e.name,"' is too long (").concat(s.length," characters). Truncating to 1024 characters.")),s=s.substring(0,1021)+"...");let a=null!==(o=null===(t=e.input_schema)||void 0===t?void 0:t.properties)&&void 0!==o?o:Object.create(null),c=null!==(i=null===(r=e.input_schema)||void 0===r?void 0:r.required)&&void 0!==i?i:[];return{type:"function",function:{name:n(e.name),description:s,parameters:{type:"object",properties:a,required:c,additionalProperties:!1}}}}function i(e,t){let r=[];for(let n of e)if("system"===n.role){if("string"==typeof n.content)t=n.content;else if(Array.isArray(n.content)){let e=n.content.find(e=>"text"===e.type);e&&"text"in e&&(t=e.text)}}else r.push({role:"tool"===n.role?"user":n.role,content:n.content});let n={messages:r};return t&&(n.system=t),n}function s(e,t){let r=[];for(let t of e)if(Array.isArray(t.content)){let e=t.content.find(e=>"tool_use"===e.type),n=t.content.find(e=>"tool_result"===e.type),o=t.content.find(e=>"text"===e.type);e?r.push({role:"assistant",content:(null==o?void 0:o.text)||"",tool_calls:[{id:e.id,type:"function",function:{name:e.name,arguments:JSON.stringify(e.input)}}],name:t.name}):n?r.push({role:"tool",tool_call_id:n.tool_use_id,content:n.content}):r.push({role:t.role,content:(null==o?void 0:o.text)||"",name:t.name})}else r.push({role:t.role,content:t.content,name:t.name});let n={messages:r};return t&&t.length>0&&(n.tools=t.map(o),n.tool_choice="auto",n.function_calling={allow_nested_function_calls:!0,allow_multiple_function_calls:!0}),n}function a(e){return{role:e.role,content:e.content,name:e.toolInput}}r.d(t,{HG:()=>i,NQ:()=>s,nJ:()=>n,r3:()=>a})},6714:(e,t,r)=>{function n(e,t){if(!e||"anthropic"===e)return{type:"anthropic",settings:{apiKey:t.anthropicApiKey||t.apiKey||""}};if("openrouter"===e)return{type:"openrouter",settings:{apiKey:t.openRouterApiKey||"",baseUrl:t.openRouterBaseUrl||"https://openrouter.ai/api/v1"}};if("openai"===e)return{type:"openai",settings:{apiKey:t.openaiApiKey||"",baseUrl:t.openaiBaseUrl||"https://api.openai.com/v1",organizationId:t.openaiOrgId||""}};throw Error("Unknown provider type: ".concat(e))}function o(e){switch(e){case"anthropic":return["claude-sonnet-4-20250514","claude-3-7-sonnet-20250219","claude-3-5-sonnet-20241022","claude-3-5-haiku-20241022","claude-3-opus-20240229"];case"openai":return["gpt-4-turbo","gpt-4o","gpt-4o-mini","gpt-4"];case"openrouter":return["deepseek/deepseek-r1","anthropic/claude-3.5-sonnet","google/gemini-2.0-flash-thinking-exp:free","google/gemini-2.0-flash-exp:free","openai/o1","openai/o1-preview","openai/gpt-4-turbo"];default:return[]}}r.d(t,{SM:()=>o,Xz:()=>n})},9632:(e,t,r)=>{r.d(t,{C7:()=>c,G8:()=>s,LZ:()=>p,nh:()=>v,ue:()=>m});var n=r(6714),o=r(3950),i=r(1491);let s=7,a=async()=>new Promise((e,t)=>{let r=indexedDB.open("kibitz_db",s);r.onerror=()=>t(r.error),r.onsuccess=()=>e(r.result),r.onupgradeneeded=e=>{let t=e.target.result;if(e.oldVersion<1){let e=t.createObjectStore("projects",{keyPath:"id"});e.createIndex("createdAt","createdAt"),e.createIndex("updatedAt","updatedAt"),e.createIndex("name","name"),e.createIndex("order","order"),t.createObjectStore("appState",{keyPath:"id"}),t.createObjectStore("mcpServers",{keyPath:"id"}).createIndex("name","name"),e.createIndex("settings.systemPrompt","settings.systemPrompt"),e.createIndex("conversations.name","conversations.name",{multiEntry:!0}),e.createIndex("conversations.messages.content","conversations.messages.content",{multiEntry:!0})}else if(e.oldVersion<2){let t=e.target.transaction;if(!t){console.error("No transaction available during upgrade");return}let r=t.objectStore("projects");r.indexNames.contains("order")||r.createIndex("order","order"),r.openCursor().onsuccess=e=>{let t=e.target.result;if(t){let e=t.value;"number"!=typeof e.order&&(e.order=t.key,t.update(e)),t.continue()}}}else if(e.oldVersion<3)t.createObjectStore("mcpServers",{keyPath:"id"}).createIndex("name","name");else if(e.oldVersion<4){let t=e.target.transaction;if(!t){console.error("No transaction available during upgrade");return}let r=t.objectStore("projects");r.openCursor().onsuccess=e=>{let t=e.target.result;if(t){let e=t.value;e.settings||(e.settings={mcpServers:[],model:"claude-3-7-sonnet-20250219",systemPrompt:"",elideToolResults:!1}),e.settings&&((["claude-2.0","claude-2.1","claude-2","claude-instant","claude-3-7-sonnet-20250219"].includes(e.settings.model)||!e.settings.model)&&(e.settings.model="claude-sonnet-4-20250514"),e.settings.provider="anthropic",e.settings.apiKey&&(e.settings.anthropicApiKey=e.settings.apiKey),e.settings.openRouterApiKey="",e.settings.openRouterBaseUrl="");try{t.update(e)}catch(r){console.error("Error updating project during migration:",r);try{t.update({...e,settings:{...e.settings,provider:"anthropic"}})}catch(e){console.error("Critical error during migration fallback:",e)}}t.continue()}},r.openCursor().onerror=e=>{console.error("Error during v4 migration:",e)}}else if(e.oldVersion<5){let t=e.target.transaction;if(!t){console.error("No transaction available during upgrade");return}let r=t.objectStore("projects");r.openCursor().onsuccess=e=>{let t=e.target.result;if(t){let e=t.value;try{e.settings&&(e.settings.providerConfig=(0,n.Xz)(e.settings.provider,e.settings),t.update(e))}catch(e){console.error("Error updating project during v5 migration:",e)}t.continue()}},r.openCursor().onerror=e=>{console.error("Error during v5 migration:",e)}}else if(e.oldVersion<6){let t=e.target.transaction;if(!t){console.error("No transaction available during upgrade");return}let r=t.objectStore("projects");r.openCursor().onsuccess=e=>{let t=e.target.result;if(t){let e=t.value;e.conversations&&Array.isArray(e.conversations)&&(e.conversations=e.conversations.map(e=>(e.messages&&Array.isArray(e.messages)&&(e.messages=e.messages.map(e=>{try{let t=(0,i.r3)(e);return{...e,role:"system"===t.role?"user":"tool"===t.role?"assistant":t.role,content:t.content,toolInput:t.name}}catch(t){return console.error("Error migrating message:",t,e),e}})),e)));try{e.settings&&(e.settings.providerConfig=(0,n.Xz)(e.settings.provider,e.settings),t.update(e))}catch(e){console.error("Error updating project during v6 migration:",e)}t.continue()}},r.openCursor().onerror=e=>{console.error("Error during v6 migration:",e)}}else if(e.oldVersion<7){let t=e.target.transaction;if(!t){console.error("No transaction available during upgrade");return}let r=t.objectStore("projects");r.openCursor().onsuccess=e=>{let t=e.target.result;if(t){let e=t.value;try{e.settings&&(e.settings.savedPrompts||(e.settings.savedPrompts=[]),t.update(e))}catch(e){console.error("Error updating project during v7 migration:",e)}t.continue()}},r.openCursor().onerror=e=>{console.error("Error during v7 migration:",e)}}}}),c=async()=>{let e=await a(),t=e=>(e.settings?e.settings={...o.Ab,...e.settings,provider:e.settings.provider||o.Ab.provider,providerConfig:e.settings.providerConfig||(0,n.Xz)(e.settings.provider||o.Ab.provider,e.settings)}:e.settings={...o.Ab},e);return new Promise((r,n)=>{let o=e.transaction(["projects","appState"],"readonly"),i=o.objectStore("projects"),s=o.objectStore("appState"),a=[],c={};i.index("order").openCursor().onsuccess=e=>{let r=e.target.result;r&&(a.push(t(r.value)),r.continue())},s.get("activeIds").onsuccess=e=>{let t=e.target.result;t&&(c.activeProjectId=t.activeProjectId,c.activeConversationId=t.activeConversationId)},o.oncomplete=()=>{r({projects:a,activeProjectId:c.activeProjectId||null,activeConversationId:c.activeConversationId||null})},o.onerror=()=>n(o.error)})},l=e=>{if(e instanceof Date)return isNaN(e.getTime())?new Date().toISOString():e.toISOString();if("string"==typeof e){let t=new Date(e);return isNaN(t.getTime())?e:t.toISOString()}if("number"==typeof e){let t=new Date(e);if(!isNaN(t.getTime()))return t.toISOString()}return new Date().toISOString()},d=e=>{if(e instanceof Date&&!isNaN(e.getTime()))return e;let t=new Date(e||Date.now());return isNaN(t.getTime())?new Date:t},u=e=>{let t=JSON.parse(JSON.stringify({...e,settings:{...e.settings,mcpServerIds:e.settings.mcpServerIds||[],provider:e.settings.provider||"anthropic",providerConfig:e.settings.providerConfig||(0,n.Xz)("anthropic",e.settings)},conversations:e.conversations.map(e=>({...e,lastUpdated:l(e.lastUpdated),messages:e.messages.map(e=>({...e,timestamp:l(e.timestamp)}))}))}));return t.conversations=t.conversations.map(e=>({...e,lastUpdated:d(e.lastUpdated),messages:e.messages.map(e=>({...e,timestamp:d(e.timestamp)}))})),t.createdAt=d(e.createdAt),t.updatedAt=d(e.updatedAt),"number"!=typeof t.order&&(t.order=Date.now()),t},p=async e=>{let t=await a();return new Promise((r,n)=>{let o=t.transaction(["projects","appState"],"readwrite");o.objectStore("projects").clear(),e.projects.forEach(e=>{let t=u(e);o.objectStore("projects").add(t)}),o.objectStore("appState").put({id:"activeIds",activeProjectId:e.activeProjectId,activeConversationId:e.activeConversationId}),o.oncomplete=()=>r(),o.onerror=()=>n(o.error)})},g=e=>JSON.parse(JSON.stringify({...e,ws:void 0,status:"disconnected"})),m=async e=>{let t=await a();return new Promise((r,n)=>{let o=t.transaction(["mcpServers"],"readwrite"),i=o.objectStore("mcpServers");try{let t=i.clear();t.onsuccess=()=>{let t=e.map(e=>new Promise((t,r)=>{let n=g(e),o=i.add(n);o.onsuccess=()=>t(),o.onerror=()=>r(o.error)}));Promise.all(t).then(()=>r()).catch(e=>{console.error("Error saving servers:",e),n(e)})},t.onerror=e=>{console.error("Error clearing servers:",e),n(t.error)}}catch(e){console.error("Error in saveMcpServers transaction:",e),n(e)}o.onerror=()=>{console.error("Transaction error in saveMcpServers:",o.error),n(o.error)}})},v=async()=>{let e=await a();return new Promise((t,r)=>{let n=[],o=e.transaction(["mcpServers"],"readonly");o.objectStore("mcpServers").openCursor().onsuccess=e=>{let t=e.target.result;t&&(n.push(t.value),t.continue())},o.oncomplete=()=>t(n),o.onerror=()=>r(o.error)})}},3950:(e,t,r)=>{r.d(t,{Ab:()=>l,Pj:()=>d,pi:()=>c});var n=r(9827),o=r(9632);let i=()=>Math.random().toString(36).substring(7),s=()=>"/operator:hypergrid:ware.hypr/shim/mcp",a=()=>{let e=window.location.protocol.endsWith("s:")?"https":"http";return"".concat(e,"://").concat(window.location.host).concat(s())},c=e=>{switch(e){case"openai":return"gpt-4o";case"openrouter":return"openai/gpt-4-turbo-preview";default:return"claude-sonnet-4-20250514"}},l={providerConfig:{type:"anthropic",settings:{apiKey:""}},provider:"anthropic",model:"claude-sonnet-4-20250514",systemPrompt:"",elideToolResults:!1,mcpServerIds:[],messageWindowSize:30,savedPrompts:[{id:"kibitz",name:"Kibitz",content:'# Kibitz: Expert Autonomous Software Developer\n\nYou are **Kibitz**, an expert AI programmer embedded in a persistent coding environment. Your primary role is to help users build, debug, and refine software projects efficiently, safely, and interactively. You specialize in real-time iteration, agentic reasoning, and maintaining software integrity.\n\n---\n\n## \uD83E\uDDE0 Your Role and Behavior\n\n- Act as a highly competent and collaborative coding assistant.\n- Only perform tasks that the user has explicitly requested.\n- Use clear reasoning to plan changes before executing them.\n- Always verify your work before continuing to the next task.\n- Communicate in simple, user-friendly language with no unnecessary technical depth unless asked.\n\n---\n\n## \uD83D\uDD01 Iteration Workflow\n\n- Begin by planning your approach; you may take extra reasoning time if the task is complex ("think", "think hard", or "ultrathink").\n- Implement only the minimal set of changes needed to advance progress.\n- After completing each step, confirm correctness based on current system outputs or user feedback.\n- If a previous step failed, investigate why using available logs or contextual signals before retrying.\n- Track and confirm progress after user validation.\n\n---\n\n## \uD83D\uDCC2 Project Conventions\n\n- Work relative to the project\'s root directory.\n- Do not reference internal system folders or absolute paths.\n- When modifying files, make sure all related logic remains consistent across the codebase.\n- Never alter database tables or execute destructive operations unless the user explicitly approves.\n- For schema changes, rely on safe, structured migrations using the project\'s standard ORM.\n- Generate assets in standard formats like SVG and avoid adding low-level system dependencies.\n\n---\n\n## \uD83E\uDDEA Execution and Debugging Practices\n\n- When fixing errors or implementing logic, rely on logged output and contextual runtime behavior for verification.\n- If debugging, never oversimplify the problem—trace it fully and document your reasoning.\n- Where applicable, simulate expected user flows to validate frontend or backend behaviors.\n- Use additional inspection or logging only if no diagnostic signals are available.\n- After 3 consecutive failures to solve a problem, recommend rollback or user intervention.\n\n---\n\n## \uD83E\uDDFE Communication Guidelines\n\n- Assume the user is non-technical; speak plainly.\n- Confirm your actions using simple phrases like:\n  *"I\'ve made the update. Let\'s see if it works now."*\n- Do not respond on behalf of platform support regarding billing or ethics; redirect the user appropriately.\n- Only answer user questions directly when they\'ve asked for help or clarification.\n- When a feature requires authentication or an external key, ask the user to supply it.\n- Avoid commenting on warnings or minor logs unless asked.\n- Never proceed with large changes (e.g. new APIs, major refactors) without explicit permission.\n\n---\n\n## \uD83D\uDD12 Data Integrity Guidelines\n\n- Use authentic data sources only with user-provided credentials or secrets.\n- Always surface clear and actionable error states if a system or API fails.\n- Guide the user toward fixing broken services instead of assuming workarounds.\n- Label empty UI states accurately and avoid showing placeholder or test data in production logic.\n- When presenting outputs, clearly indicate their reliability and origin.\n\n---\n\n## \uD83D\uDEA6 Sample Workflow\n\n**User:**\n"Fix the bug in the payment route where it returns success even on failure."\n\n**Kibitz:**\n- Plan: Read the file, find the return code logic, verify error condition, change response code.\n- Change: Adjusted the response to correctly return an error on failure.\n- Test: Simulated a request, and confirmed the new status code appears as expected.\n- Message:\n  *"I\'ve updated the code to return the correct error status. Let me know if it behaves as expected."*\n\n---\n\n## ✅ Summary\n\n- Think before you act.\n- Stay focused on user requests.\n- Never make assumptions about environment, permissions, or data.\n- Be helpful, safe, and concise.',createdAt:new Date},{id:"kibitz-claude",name:"Kibitz GitHub Issue Agent",content:"You are **Kibitz**, an elite and expert AI software engineer pair-programmer. Your primary task is to analyze and resolve specific GitHub issues within a designated local project directory. You follow a precise workflow, leveraging your capabilities to interact with the codebase and external tools like the GitHub CLI (`gh`) and package managers (`npm`). Your approach is systematic, validates thoroughly, and adheres to best practices for contributing code.\n\n---\n\n**\uD83C\uDFE0 Current Working Directory:**\n\nYou are operating strictly within this absolute path:\n`[PROJECT_ROOT_PATH]`\n**=> IMPORTANT:** You *MUST* replace `[PROJECT_ROOT_PATH]` with the actual, full absolute path to the user's project directory on their system before using this template.\n\n---\n\n**\uD83E\uDDE0 Reasoning Depth (Choose One):**\n\nSelect and state the most appropriate level at the beginning of your response based on the complexity of the GitHub issue:\n*   `think`: For simple issues (e.g., typos, minor styling fixes).\n*   `think hard`: For bugs requiring moderate debugging or feature enhancements.\n*   `ultrathink`: For complex architectural issues, significant refactors related to the issue, or problems impacting multiple system parts.\n\n---\n\n**\uD83C\uDFAF GitHub Issue Resolution Workflow:**\n\nYour task is to resolve a specific GitHub issue (provided by the user, likely via its number or URL). Follow these steps precisely:\n\n1.  **Understand the Issue:** Use the `gh issue view <issue_identifier>` command to retrieve and thoroughly understand the problem described in the GitHub issue.\n2.  **Formulate Plan:** Based on your understanding, create a concise plan (markdown bullet points, maximum 7) detailing how you will approach fixing *this specific* issue within the codebase.\n3.  **Locate & Implement:** Search the codebase for relevant files and implement the necessary changes to address the issue as outlined in your plan. Use your inherent file interaction capabilities.\n4.  **Test the Fix:** Write or run relevant tests (`npm run test` or equivalent project test command) to verify that your changes correctly fix the issue and do not introduce regressions. Show test output.\n5.  **Validate Code Integrity:** After making *any* code modification, you **must** execute the project's static analysis and build commands.\n    *   Run: `npm run lint`\n    *   Run: `npm run build`\n    *   Ensure the code passes linting (including type checking if configured) and builds successfully. If either command reports errors or failures, you must show the error output, show the code fixes you implement to resolve those specific errors, and then *re-run* the validation commands (`npm run lint`, `npm run build`) until both pass cleanly. This validation/fix loop is mandatory.\n6.  **Create Commit:** Stage your changes and create a descriptive commit message that clearly summarizes the fix, referencing the GitHub issue number. Use your git capabilities.\n7.  **Submit Pull Request:** Push your branch with the fix and create a Pull Request using the `gh pr create` command. Provide a clear description for the PR.\n\n---\n\n**\uD83D\uDD11 Core Engineering Principles:**\n\n*   **Minimal Change (Chesterton's Fence):** Implement only the minimum necessary modifications to resolve the specific GitHub issue.\n*   **Validated & Tested Code:** Your work is not complete until the fix is verified by tests and passes linting/building without errors.\n*   **Clarity:** If the GitHub issue description is unclear or requires more context from the user, ask *one* single, precise clarifying question about the issue *before* formulating your plan.\n*   **Tool Use:** You are expected to use the `gh` command-line tool for GitHub interactions (viewing issues, creating PRs) and standard project commands (`npm`, `git`) for development workflow.\n\n---\n\n**\uD83D\uDCDD Output Format:**\n\nBegin your response by stating the overall Reasoning Depth chosen. Then, follow the sequential steps of the workflow for the provided GitHub issue: state the issue identifier, provide the plan, show actions and their results (including `gh issue view` output, code changes, test output, validation command outputs, error fixes, re-validation, commit message, and `gh pr create` output). Conclude by confirming the PR has been created.\n\n---\n\n**Analyze the provided GitHub issue identifier. Determine the appropriate reasoning depth. State the depth and begin executing the issue resolution workflow, reporting each step as you complete it.**",createdAt:new Date}]},d=(0,n.v)((e,t)=>{let r=e=>{console.log("saving ".concat(JSON.stringify({keys:e}))),fetch("".concat("/kibitz:kibitz:nick.hypr","/api/keys"),{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({keys:e})}).catch(e=>{console.error("Failed to save API keys:",e)})},n=async r=>{try{e(e=>({servers:e.servers.map(e=>e.id===r.id?{...e,status:"connecting",error:void 0}:e)}));{let n={...r,status:"connected",error:void 0,tools:[{name:"authorize",description:"Configure the Hypergrid MCP shim with authentication credentials",input_schema:{type:"object",properties:{url:{type:"string",description:"The base URL for the Hypergrid API"},token:{type:"string",description:"The authentication token"},client_id:{type:"string",description:"The unique client ID"},node:{type:"string",description:"The Hyperware node name"}},required:["url","token","client_id","node"]}},{name:"search-registry",description:"Search through all listed providers to find relevant data sources",input_schema:{type:"object",properties:{query:{type:"string",description:"Search query for providers"}},required:["query"]}},{name:"call-provider",description:"Make a request to a previously discovered Provider",input_schema:{type:"object",properties:{providerId:{type:"string",description:"The provider ID"},providerName:{type:"string",description:"The provider name"},callArgs:{type:"array",items:{type:"array",items:{type:"string"},minItems:2,maxItems:2},description:"Array of [key, value] pairs for provider arguments"}},required:["providerId","providerName","callArgs"]}}]},i={servers:t().servers.map(e=>e.id===r.id?n:e)};return e(i),(0,o.ue)(i.servers).catch(e=>{console.error("Error saving MCP servers:",e)}),n}}catch(e){return console.error("Failed to connect to server ".concat(r.name)),{...r,status:"error",error:"Failed to connect"}}};return{projects:[],activeProjectId:null,activeConversationId:null,initialized:!1,servers:[],apiKeys:{},hasLoadedApiKeysFromServer:!1,saveApiKeysToServer:r,initialize:async()=>{if(!t().initialized)try{var r,s;let{apiKeys:c}=t();if(0===Object.keys(c).length&&!t().hasLoadedApiKeysFromServer)try{let t=await fetch("".concat("/kibitz:kibitz:nick.hypr","/api/keys"));if(t.ok){let r=await t.json();r.keys&&e({apiKeys:r.keys,hasLoadedApiKeysFromServer:!0})}}catch(e){console.error("Failed to load API keys:",e)}await (0,o.nh)();{let t;let r={id:"hypergrid",name:"Hypergrid",uri:a(),status:"disconnected"};try{t=await n(r)}catch(e){console.error("Failed to connect to Hypergrid MCP:",e),t={...r,status:"error",error:"Failed to connect"}}e({servers:[t]}),await (0,o.ue)([t])}let d=await (0,o.C7)(),u=d.projects.length>0;if(console.log("Loading projects from IndexedDB:",JSON.stringify(d)),u){let t=d.projects.map(e=>({...e,settings:{...e.settings,mcpServerIds:["hypergrid"]}}));e({projects:t,activeProjectId:d.activeProjectId,activeConversationId:d.activeProjectId&&d.activeConversationId?d.activeConversationId:null})}else{let n={id:i(),name:"(New Chat)",lastUpdated:new Date,messages:[],createdAt:new Date},{apiKeys:o}=t(),a={id:i(),name:"Default Project",settings:{...l,apiKey:null!==(r=o.apiKey)&&void 0!==r?r:"",groqApiKey:null!==(s=o.groqApiKey)&&void 0!==s?s:"",mcpServers:[],mcpServerIds:["hypergrid"]},conversations:[n],createdAt:new Date,updatedAt:new Date,order:Date.now()};e({projects:[a],activeProjectId:a.id,activeConversationId:n.id})}e({initialized:!0})}catch(r){console.error("Error initializing data");let t={id:i(),name:"Default Project",settings:{...l,mcpServers:[]},conversations:[],createdAt:new Date,updatedAt:new Date,order:Date.now()};e({projects:[t],activeProjectId:t.id,initialized:!0})}},createProject:(r,n)=>{let{projects:s,activeProjectId:a}=t(),c=s.find(e=>e.id===a),d=i(),u=t().servers.filter(e=>"connected"===e.status).map(e=>e.id),p={id:d,name:r,settings:{...l,...c&&{apiKey:c.settings.apiKey,groqApiKey:c.settings.groqApiKey,systemPrompt:""},mcpServerIds:u,...n},conversations:[],createdAt:new Date,updatedAt:new Date,order:Math.max(...s.map(e=>e.order||0),0)+1};e(e=>({projects:[...e.projects,p],activeProjectId:d})),(0,o.LZ)({projects:[...s,p],activeProjectId:d,activeConversationId:null}).catch(e=>{console.error("Error saving state:",e)});let g=i();e(e=>({projects:e.projects.map(e=>e.id!==d?e:{...e,conversations:[{id:g,name:"(New Chat)",lastUpdated:new Date,messages:[],createdAt:new Date}],updatedAt:new Date}),activeConversationId:g}));let m=t();(0,o.LZ)({projects:m.projects,activeProjectId:m.activeProjectId,activeConversationId:m.activeConversationId}).catch(e=>{console.error("Error saving state:",e)})},updateProjectSettings:(t,n)=>{e(e=>{let i=e.projects.find(e=>e.id===t),s={...e.apiKeys},a=!1;i&&n.settings&&(n.settings.apiKey!==i.settings.apiKey&&(s.apiKey=n.settings.apiKey||"",a=!0),n.settings.groqApiKey!==i.settings.groqApiKey&&(s.groqApiKey=n.settings.groqApiKey||"",a=!0));let c={...e,apiKeys:a?s:e.apiKeys,projects:e.projects.map(e=>{if(e.id!==t)return e;let r=e.conversations;return n.conversations&&(r=n.conversations.map(t=>{let r=e.conversations.find(e=>e.id===t.id);return r&&"(New Chat)"!==r.name?{...t,name:r.name}:t})),{...e,settings:n.settings?{...e.settings,...n.settings,mcpServerIds:void 0!==n.settings.mcpServerIds?n.settings.mcpServerIds:e.settings.mcpServerIds}:e.settings,conversations:r,updatedAt:new Date}})};return(0,o.LZ)(c).catch(e=>{console.error("Error saving state:",e)}),a&&r(s),c})},deleteProject:r=>{var n,i;let{projects:s,activeProjectId:a}=t(),c=s.find(e=>e.id!==r),l={projects:s.filter(e=>e.id!==r),activeProjectId:a===r&&c?c.id:a,activeConversationId:a===r&&c?null!==(i=null===(n=c.conversations[0])||void 0===n?void 0:n.id)&&void 0!==i?i:null:t().activeConversationId};e(l),(0,o.LZ)(l).catch(e=>{console.error("Error saving state:",e)})},createConversation:(t,r)=>{let n=i();e(e=>{let i={...e,projects:e.projects.map(e=>e.id!==t?e:{...e,conversations:[{id:n,name:r||"(New Chat)",lastUpdated:new Date,createdAt:new Date,messages:[]},...e.conversations],updatedAt:new Date}),activeConversationId:n};return(0,o.LZ)(i).catch(e=>{console.error("Error saving state:",e)}),i})},deleteConversation:(t,r)=>{let n=i();e(e=>{var i,s;let a=e.projects.map(e=>{if(e.id!==t)return e;let o=e.conversations.filter(e=>e.id!==r);if(0===o.length){let t={id:n,name:"(New Chat)",lastUpdated:new Date,messages:[],createdAt:new Date};return{...e,conversations:[t],updatedAt:new Date}}return{...e,conversations:o,updatedAt:new Date}}),c=a.find(e=>e.id===t),l=(null==c?void 0:c.conversations.length)===1?n:e.activeConversationId===r?null!==(s=null==c?void 0:null===(i=c.conversations.find(e=>e.id!==r))||void 0===i?void 0:i.id)&&void 0!==s?s:null:e.activeConversationId,d={...e,projects:a,activeConversationId:l};return(0,o.LZ)(d).catch(e=>{console.error("Error saving state:",e)}),d})},renameConversation:(t,r,n)=>{"(New Chat)"!==n&&e(e=>{let i={...e,projects:e.projects.map(e=>e.id!==t?e:{...e,conversations:e.conversations.map(e=>e.id===r?{...e,name:n}:e),updatedAt:new Date})};return(0,o.LZ)(i).catch(e=>{console.error("Error saving state:",e)}),i})},renameProject:(t,r)=>{e(e=>{let n={...e,projects:e.projects.map(e=>e.id===t?{...e,name:r,updatedAt:new Date}:e)};return(0,o.LZ)(n).catch(e=>{console.error("Error saving state:",e)}),n})},setActiveProject:r=>{let{projects:n}=t(),i=r?n.find(e=>e.id===r):null;e(e=>{let t={...e,activeProjectId:r,activeConversationId:i&&i.conversations.length>0&&!e.activeConversationId?i.conversations[0].id:e.activeConversationId};return(0,o.LZ)(t).catch(e=>{console.error("Error saving state:",e)}),t})},setActiveConversation:t=>{e(e=>{let r={...e,activeConversationId:t};return(0,o.LZ)(r).catch(e=>{console.error("Error saving state:",e)}),r})},addServer:async r=>{if("hypergrid"!==r.id){console.warn("Shim mode: adding additional MCP servers is disabled");return}e(e=>({servers:[...e.servers,{...r,status:"connecting",error:void 0}]}));try{let i=await n(r),s={servers:t().servers.map(e=>e.id===r.id?i:e)};return e(s),await (0,o.ue)(s.servers),i}catch(i){let n={servers:t().servers.map(e=>e.id===r.id?{...e,status:"error",error:"Connection failed"}:e)};return e(n),(0,o.ue)(n.servers).catch(e=>{console.error("Error saving MCP servers:",e)}),t().servers.find(e=>e.id===r.id)}},removeServer:e=>{console.warn("Shim mode: removing MCP servers is disabled")},reconnectServer:async r=>{if("hypergrid"!==r)throw Error("Shim mode: only Hypergrid server can be reconnected");let i=t().servers.find(e=>e.id===r);if(!i)throw Error("Server not found");try{let s=await n(i);return e(e=>({servers:e.servers.map(e=>e.id===r?s:e)})),await (0,o.ue)(t().servers),s}catch(t){throw e(e=>({servers:e.servers.map(e=>e.id===r?{...e,status:"error",error:"Reconnection failed"}:e)})),Error("Failed to reconnect")}},executeTool:async(r,n,i)=>{{let s;let a=t().servers.find(e=>e.id===r);if(!a)throw Error("Server not found");if("authorize"===n){let{url:n,token:s,client_id:c,node:l}=i;try{let i=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json","X-Client-ID":c,"X-Token":s},body:JSON.stringify({SearchRegistry:"test"})});if(!i.ok&&404!==i.status)throw Error("Configuration test failed: ".concat(i.status," ").concat(i.statusText));let d={...a,uri:n,clientId:c,token:s};return e(e=>({servers:e.servers.map(e=>e.id===r?d:e)})),await (0,o.ue)(t().servers),"✅ Successfully authorized! Configuration saved.\n\nThe MCP server is now configured and ready to use with:\n- Node: ".concat(l,"\n- Client ID: ").concat(c,"\n- URL: ").concat(n,"\n\nYou can now use the search-registry and call-provider tools.")}catch(e){return"❌ Authorization failed: ".concat(e.message,"\n\nPlease check your credentials and try again.")}}if(!a.clientId||!a.token)return'⚠️ This MCP server is not configured yet. Please use the "authorize" tool first with your Hypergrid credentials.\n\nExample: Use the authorize tool with url "...", token "...", client_id "...", and node "..."';if("search-registry"===n)s={SearchRegistry:i.query};else if("call-provider"===n){let{providerId:e,providerName:t,callArgs:r}=i;s={CallProvider:{providerId:e,providerName:t,arguments:r}}}else throw Error("Unknown tool: ".concat(n));let c={"Content-Type":"application/json","X-Client-ID":a.clientId,"X-Token":a.token};try{let e=await fetch(a.uri,{method:"POST",headers:c,body:JSON.stringify(s)}),t=await e.text();return console.error("".concat(n,": Response received (status ").concat(e.status,")")),t}catch(e){return console.error("".concat(n,": Request failed:"),e),'{"error": "Request Failed: '.concat(e.message,'"}')}}},attemptLocalMcpConnection:async()=>{let r="hypergrid",i=a(),s=t().servers.find(e=>e.id===r);if(s)return s;try{let s=await n({id:r,name:"Hypergrid",uri:i,status:"disconnected"});if("connected"===s.status)return e(e=>({servers:[...e.servers,s]})),await (0,o.ue)(t().servers),s;return null}catch(e){return console.log("Local MCP not available"),null}}}})}}]);